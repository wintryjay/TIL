#### 어떤 운영 체제에서 어떤 프로그래밍 언어를 사용하든 좋은 프로그램은 항상 적절한 자료 구조와 효율적인 알고리즘을 바탕으로 한다. 
	- 비전공자인 나로서는 기본구조를 알아야 한다고 생각했고, 많은 서칭을 통해서 괜찮은 책을 추천받아 이를 공부하고 여기에 정리하고자 한다.
		* 공부할 책은 "누구나 자료구조와 알고리즘(도서출판 길벗)" 이다.

</br>

## 5장 빅 오를 사용하거나 사용하지 않는 코드 최적화

* [5.1 선택 정렬](#선택-정렬)
* [5.2 선택 정렬 실제로 해보기](#선택-정렬-실제로-해보기)
* [5.3 선택 정렬 구현](#선택-정렬-구현)
* [5.4 선택 정렬의 효율성](#선택-정렬의-효율성)
* [5.5 상수 무시하기](#상수-무시하기)
* [5.6 마무리](#마무리)

[뒤로](https://github.com/wintryjay/TIL/tree/main/DataStructure)

</br>

### 5장 빅 오를 사용하거나 사용하지 않는 코드 최적화
  * 빅 오는 알고리즘 간 차이를 드러내고 주어진 상황에 알맞은 알고리즘을 결정하게 해주는 훌륭한 도구지만, 유일하지는 않다.
    * 실제로 빅 오 표기법에서는 한 알고리즘이 다른 알고리즘보다 훨씬 빠른 경우에도 두 경쟁 알고리즘을 정확히 똑같은 방식으로 표현한다.
      효율성이 같아 보이는 두 알고리즘을 구별해 내서 더 빠른 알고리즘을 고르는 법을 알아보자.
      
### 선택 정렬
  * 4장에서 배운 데이터 정렬 알고리즘인 버블 정렬은 효율성이 "O(N<sup>2</sup>)"이다.
  1. 선택 정렬은 배열의 각 셀을 왼쪽부터 오른쪽 방향으로 확인하면서 어떤 값이 최솟값인지 결정
    * 한 셀씩 이동하면서 현재까지 가장 작은 값을 변수에 저장(실제로는 최솟값의 인덱스까지 저장할 수 있다.)
      * 변수에 들어 있는 값보다 작은 값이 들어 있는 셀을 만나면 변수가 새 인덱스를 가리키도록 값을 대체
  2. 최소값이 어느 인덱스에 있는지 알았기 때문에 그 인덱스의 값과 패스스루를 처음 시작했을 때의 값을 교환한다.
    * 첫 패스스루의 인덱스는 0, 두 번째 패스스루에서는 인덱스 1
  3. 데이터가 모두 정렬될 때 까지 1, 2단계를 반복
    * 패스스루 인덱스와 최소값의 교환이다.
    
### 선택 정렬 실제로 해보기
  * 배열 [4, 2, 7, 1, 3] 이 있다고 할 때,
    [4, 2, 7, 1, 3] --> [1, 2, 7, 4, 3] --> [1, 2, 3, 4, 7]

### 선택 정렬 구현
  ```js
  function selectionSort(array){
    for(var i=0; i<array.length; i++){
      var lowestNumberIndex = i;
      for (var j=i+1; j<array.length; j++){
        if(array[i] < array[lowestNumberIndex]){
          lowestNumberIndex = j;
        }
      }
      if(lowestNumberIndex !=i){
        var temp = array[i];
        array[i] = array[lowestNumberIndex];
        array[lowestNumberIndex] = temp;
      }
    }
    return array;
  }
  ```
### 선택 정렬의 효율성
  * 선택 정렬은 비교와 교환, 두 종류의 단계를 포함한다.</br>
    다시말해 각 패스스루 내에서 각 원소를 현재까지 찾은 최솟값과 비교하고, 최솟값을 올바른 위치에 있는 수와 교환한다.
  * 비교 : 원소가 "N개가 있을 때 (N-1)+(N-2)+(N-3)...+1" 번의 비교가 일어난다.
  * 교환 : 패스스루 한번 당 최대 한 번이 일어난다.
    * 최악의 시나리오인 경우 버블 정렬과 달리 빠짐없이 교환을 한 번(N-1) 해야 한다.
  * 따라서, 선택 정렬은 버블 정렬보다 단계 수가 반 정도 적다.
    * 다시 말하자면, 선택 정렬은 버블 정렬보다 2배 더 빠르다.</br>
<!-- table -->
|N개의 원소|버블 정렬에서 최대 단계 수|선택 정렬에서 최대 단계 수|
|:--:|:--:|:--:|
|5|20|14(10+4)|
|10|90|54(45+9)|
|20|380|199(180+19)|
|40|1560|819(780+39)|
|80|6320|3239(3160+79)|

### 상수 무시하기
  * 빅 오 표기법에서는 선택 정렬과 버블 정렬을 정확히 같은 방식으로 설명한다. 
    * **빅 오 표기법은 데이터 원소 수에 비례해 얼마나 많은 단계 수가 필요한가를 기술한 것**
    * 언뜻 보기에, 선택 정렬의 단계 수가 대략 N<sup>2</sup>/2 로 보이기 때문에,</br>
      선택 정렬의 효율성을 "O(N<sup>2</sup>/2)로 설명해도 괜찮아 보인다.
<!-- table -->
|N개의 원소|N<sup>2</sup>/2|선택 정렬에서 최대 단계 수|
|:--:|:--:|:--:|
|5|5<sup>2</sup>/2=12.5|14(10+4)|
|10|10<sup>2</sup>/2=50|54(45+9)|
|20|20<sup>2</sup>/2=200|199(180+19)|
|40|40<sup>2</sup>/2=800|819(780+39)|
|80|80<sup>2</sup>/2=3200|3239(3160+79)|
  * **빅 오의 규칙**
    * **빅 오 표기법은 상수를 무시한다.**
      * 빅오 표기법은 지수가 아닌 수는 포함하지 않는다
      * 즉, O(N<sup>2</sup>/2) = O(N<sup>2</sup>) 이고, O(2N) = O(N) = O(N/2) = O(100N) 이다.
      * 선택 정렬과 버블 정렬 두 알고리즘 모두 빅 오로는 O(N<sup>2</sup>)이지만, 선택 정렬은 사실 버블 정렬보다 2배 빠르다.
      
### 빅 오의 역할
  * 빅 오는 버블 정렬과 선택 정렬 간에 차이를 두지 않지만, 알고리즘의 장기적인 증가율을 분류하기 위한 훌륭한 방법이기에 중요함
    * 즉, 어느정도 크기의 데이터에 대해서 O(N)이 항상 O(N<sup>2</sup>)보다 빠르다.
  * 빅 오는 데이터가 많을 때 한 알고리즘이 어떤 시점부터 다른 알고리즘보다 더 빠름을 보장하므로</br>
    빅 오에서 서로 다른 분류에 속하는 두 알고리즘이라면 어떤 알고리즘을 써야 할 지 대체로 알 수 있으며, 따라서 빅 오는 매우 유용한 도구다.
  * 두 알고리즘이 같은 분류에 속하더라도 반드시 두 알고리즘의 처리 속도가 같지 않다는 점을 알아야 한다.
    * 버블 정렬과 선택 정렬은 둘 다 O(N<sup>2</sup>)이지만, 어쨌든 버블 정렬은 선택 정렬보다 두 배 느리다. 
  * 빅오에서 **다른 분류**에 속하는 알고리즘을 대조할 때는 빅 오가 완벽한 도구지만, **같은 분류**에 속하는 두 알고리즘이라면 어떤 알고리즘이 더 빠를지 알기 위해 더 분석해야 한다.
      
### 마무리
  * 빅 오를 사용해 알고리즘이 대체로 얼마나 효율적인지 알 수 있고, 빅 오에서 같은 분류에 속하는 두 알고리즘도 비교할 수 있다.
  * 두 알고리즘의 효율성을 비교할 때 고려할 요인은 또 있다.
    * 지금까지는 최악의 시나리오에서 얼마나 느린가만 생각했다. 하지만, 최악의 시나리오보다, 최선의 시나리오보다, 평균의 시나리오가 대체로 일어난다.
      
[위로](#5장-빅-오를-사용하거나-사용하지-않는-코드-최적화)
