#### 어떤 운영 체제에서 어떤 프로그래밍 언어를 사용하든 좋은 프로그램은 항상 적절한 자료 구조와 효율적인 알고리즘을 바탕으로 한다. 
	- 비전공자인 나로서는 기본구조를 알아야 한다고 생각했고, 많은 서칭을 통해서 괜찮은 책을 추천받아 이를 공부하고 여기에 정리하고자 한다.
		* 공부할 책은 "누구나 자료구조와 알고리즘(도서출판 길벗)" 이다.

</br>

## 3장 빅 오 표기법

* [3.1 빅오](#빅-오-단계-수-계산)
* [3.2 상수 시간과 선형 시간](#상수-시간과-선형-시간)
* [3.3 같은 알고리즘, 다른 시나리오](#같은-알고리즘-다른-시나리오)
* [3.4 세 번째 유형의 알고리즘](#세-번째-유형의-알고리즘)
* [3.5 로가리즘](#로가리즘)
* [3.6 O(log N) 해석](#Olog-N의-해석)
* [3.7 마무리](#마무리)

[뒤로](https://github.com/wintryjay/TIL/tree/main/DataStructure)

</br>

### 3장 빅 오 표기법
  * 빅 오 표기법을 알면 일관되고 간결한 방법으로 어떤 알고리즘이든 분석할 수 있는 도구가 생긴다.
    * 컴퓨터 사이언티스트 간에 시간 복잡도를 쉽게 소통할 목적으로 자료 구조와 알고리즘의 효율성을
      간결하고 일관된 언어로 설명하기 위해 수학적 개념을 차용
    * 위의 개념을 형식화한 표현을 "빅 오" 표기법이라 부르며, 빅 오 표기법을 사용해 주어진 알고리즘의
      효율성을 쉽게 분류하고 이해시킬 수 있다.
      
### 빅 오: 단계 수 계산
  * "빅 오"는 시간 단위가 아닌 알고리즘에 필요한 단계 수만을 고려함으로써 일관성을 유지
    * "O(N)"은 일반적으로 "빅 오 N" 또는 "차수 N" 또는 "오 N"으로 발음하며, 표기법은 한 가지이다.
  * "O(1)"은 데이터의 크기에 상관없이 알고리즘에 필요한 단계수가 일정하다는 의미
    * "O(1)" 분류에 속하는 연산으로는 배열 읽기, 배열 끝에 삽입과 삭제가 있다.
  * "O(N)"은 빅 오 표기법으로 선형 검색의 효율성을 표현 하는 방법이다.
    * "선형 검색"은 배열에 N개의 원소가 있을 때 알고리즘을 끝내는데 최대 N단계까지 걸릴 수 있다.
      이를 빅 오 표기법으로 표현하면 "O(N)"이다.
      
### 상수 시간과 선형 시간
  * "빅 오" 표기법은 알고리즘에 얼마나 많은 단계가 필요한지를 알고리즘이 처리할 데이터 원소 수에 따라 설명한다.
    즉, 빅 오는 '데이터가 증가할수록 단계 수는 어떻게 변하는가?' 에 대한 답을 내릴 때 사용한다.
  * "O(N)"은 완벽한 대각선을 그린다. 다시 말해, 데이터가 많아질수록 알고리즘에 필요한 단계 수도 늘어난다.
    * 이런 이유로 O(N)을 "선형 시간(linear time)" 이라고도 부른다.
  * "O(1)"은 완벽한 수평선을 그리는데 데이터가 얼마나 많든 상관없이 알고리즘에 걸리는 단계 수가 항상 일정하기 때문이다.
    * 그래서 O(N)을 "상수 시간(constant time)" 이라고도 부른다.
  * "O(1)"은 두 단계 이상 걸리는 알고리즘도 표현할 수 있다. ('왜 2 단계면, O(2)가 아니고 O(1)인가?')
    * 데이터가 아무리 늘어나도 단계 수는 상수로 유지되므로 상수 시간이라 할 수 있으며 빅 오 표기법으로는 O(1)이라 설명할 수 있다.
    * 다시 말하자면, O(1)은 데이터가 아무리 커지더라도 단계 수가 변하지 않는 모든 알고리즘을 표현하는 방법이다.
  * "O(1)"은 그 어떤 "O(N)"알고리즘보다도 더 효율적이다.
    * 왜냐하면, 데이터가 증가할수록 "O(N)"은 "O(1)"보다 덜 효율적인 어떤 지점에 반드시 도달하고, 이 지점부터 데이터 양이
      무한대로 갈 때까지 바뀌지 않는다.
      
 ### 같은 알고리즘, 다른 시나리오
  * 전체적인 관점에서 선형 검색의 효율성을 설명한다면 "최선의 시나리오"는 "O(1)", "최악의 시나리오"는 "O(N)"을 의미한다.
    * 별도로 표시하지 않는 한 빅 오 표기법은 일반적으로 최아의 시나리오를 의미한다.
    * 이는 "비관적인"접근이 더 나은 접근 도구일 수 있기 때문이다. 최악의 시나리오에서 알고리즘이 얼마나 비 효율적인지
      정확히 알면 최악을 대비함과 동시에 알고리즘의 선택에 중요한 영향을 미칠 수 있다.
    
### 세 번째 유형의 알고리즘
  * 정렬된 배열에서 "이진 검색"은 "선형 검색"보다 훨씬 빠르다.
    * 데이터가 커질수록 단계 수가 늘어나므로 이진 검색은 O(1)이라고 할 수 없고,
      검색하고 있는 원소 수보다 단계 수가 적으므로 O(N)으로 할 수 없다.
    * 이진 검색은 "O(1)과 O(N) 사이 어딘가에 존재한다."
  * "O(log N)"은 "로그 시간(log time)의 시간 복잡도"라고 말하며, 보통 이진 검색의 시간 복잡도를 의미한다.
    * 간단하게, O(log N)은 데이터가 두 배로 증가할 때마다 한 단계씩 늘어나는 알고리즘을 설명하는 빅오의 방법이다.
  * 효율적으로는 O(1) < O(log<sub>2</sub> N) < O(N) 순 이다.
  
### 로가리즘
  * "로가리즘(logarithm)"은 로그를 풀어쓴 단어로, 로그는 우리가 배웠듯이 "지수와 역의 관계"다.
    * 기존에 우리가 배웠던 접근방식에서 조금 다르게, 우리는 "N을 1이 될 때까지 몇 번이나 반(2)으로 나눠야 할 지" 생각해보자.
    
### O(log N)의 해석
  * O(N)은 데이터 원소가 N개 있으면 알고리즘에서 N단계가 걸린다는 뜻 = 원소가 8개 :: 알고리즘 8단계
  * O(log N)은 데이터 원소 N개가 있으면 알고리즘은 log<sub>2</sub> N단계가 걸린다 = 원소가 8개 :: 알고리즘 3단계(log<sub>2</sub> 8)
    * 원소 8개를 절반으로 계속해서 나누면 원소가 하나 남을 때까지 3단계가 걸린다.
  * 다시 말하자면, O(log N)은 원소가 하나가 될 때까지 데이터 원소를 계속해서 반으로 줄이는 만큼의 단계 수가 걸린다는 뜻이다.
    
### 마무리
  * 빅 오 표기법은 어떤 알고리즘이든 비교할 수 있는 일관된 시스템이다.
    * 실제로 쓰이는 시나리오를 분석해서 다양한 자료 구조와 알고리즘 중 사용자의 코드를 더 빠르게 하고 더 큰 부하도 처리할 수 있는 방법을 고를 수 있다.
    
* [위로](#3장-빅-오-표기법)
