#### 어떤 운영 체제에서 어떤 프로그래밍 언어를 사용하든 좋은 프로그램은 항상 적절한 자료 구조와 효율적인 알고리즘을 바탕으로 한다. 
	- 비전공자인 나로서는 기본구조를 알아야 한다고 생각했고, 많은 서칭을 통해서 괜찮은 책을 추천받아 이를 공부하고 여기에 정리하고자 한다.
		* 공부할 책은 "누구나 자료구조와 알고리즘(도서출판 길벗)" 이다.

</br>

## 4장 빅 오로 코드 속도 올리기

* [4.1 버블 정렬](#버블-정렬)
* [4.2 버블 정렬 실제로 해보기](#버블-정렬-실제로-해보기)
* [4.3 버블 정렬 구현](#버블-정렬-구현)
* [4.4 버블 정렬의 효율성](#버블-정렬의-효율성)
* [4.5 이차 문제](#이차-문제)
* [4.6 선형 해결법](#선형-해결법)
* [4.7 마무리](#마무리)

[뒤로](https://github.com/wintryjay/TIL/tree/main/DataStructure)

</br>

### 4장 빅 오로 코드 속도 올리기
  * 빅 오 표기법은 알고리즘을 객관적인 방법으로 측정할 수 있어서 경쟁 알고리즘을 비교할 때 훌륭한 도구이다.
  * 빅오를 사용하면 내가 만든 알고리즘과 세상에 존재하는 범용 알고리즘을 비교할 기회가 생기고, </br>
    "이 알고리즘이 일반적으로 쓰이는 알고리즘만큼 빠른가 혹은 느린가?"라고 자문해 볼 수 있다.
    
### 버블 정렬
  * "정렬 알고리즘"은 컴퓨터 과학 분야에서 폭넓게 연구된 주제이며, 이러한 알고리즘은 </br>
    정렬되지 않은 배열이 주어졌을 때, 어떻게 오름차순으로 정렬할 수 있을까? 의 문제를 해결한다.
  * "단순 정렬(simple sort)" 알고리즘 분류는 이해하기 쉽기에 이렇게 불리지만, 더 빠르다고 알려진 정렬 알고리즘보다 비효율적이다.
  * "버블 정렬(bubble sort)"은 매우 기본적인 정렬 알고리즘으로, "패스스루(paththrough)"와 같은 알고리즘 주요 단계들을 '통과'하여</br>
    배열이 완전히 정렬될 때 까지 같은 절차를 반복한다.
  
### 버블 정렬 실제로 해보기
  * [4, 2, 7, 1, 3] > [2, 4, 7, 1, 3] > [2, 4, 1, 7, 3] > [2, 4, 1, 3, 7] > </br>
    [2, 1, 4, 3, 7] > [2, 1, 3, 4, 7] > [1, 2, 3, 4, 7]
  * 16 단계에 걸쳐 정렬이 된다.
    
### 버블 정렬 구현
  ```python
  def bubble_sort(list):
    unsorted_until_index = len(list)-1
    sorted = False
    
    while not sorted:
      sorted =True
      for i in range(unsorted_until_index):
        if list[i] > list[i+1]:
          sorted = False
          list[i], list[i+1] = list[i+1], list[i]
      unsorted_until_index = unsorted_until_index - 1
      
  list = [4, 2, 7, 1, 3]
  bubble_sort(list)
  print(list) # [1, 2, 3, 4, 7]
  ```
    
### 버블 정렬의 효율성
  * 버블 정렬 알고리즘에 포함된 단계는 2 종류
    * 비교: 어느 쪽이 더 큰지 두 수를 비교
    * 교환(swap): 정렬하기 위해 두 수를 교환
  * 비교는 원소 N개가 있을 때, 총 (N-1)+(N-2)+(N-3)+ ... + 1 번의 비교를 수행
  * 교환은 "최악의 시나리오"일 경우 비교와 같은 단계 수가 필요하다
  * 따라서, 버블 정렬은 원소 수가 증가할수록 단계 수가 기하급수적으로 늘어나는 "O(N<sup>2</sup>)"표기법을 사용한다.
    * 데이터가 늘어날수록 단계수가 급격하게 증가하므로, 상당히 비효율적인 알고리즘이다.
  * "O(N<sup>2</sup>)"을 "이차 시간(quadratic time)"이라고도 부른다.
  
### 이차 문제
  * 배열에 중복 값이 있는지 확인하는 자바 스크립트 애플리케이션을 작성할 때 가장 먼저 떠오르는 방법은 "이중 for문"을 사용하는 것인데..
  ```javascript
  function hasDuplicateValue(array){
    for(var i = 0; i < array.length; i++){
      for(var j = 0; j < array.length; j++){
        if(i !== j && array[i] == array[j]){
          return true;
        }
      }
    }
    return false;
  }
  ```
  * 이럴 경우, 배열에 원소 N개가 있을 때 함수는 N<sup>2</sup>번의 비교를 수행한다. 즉 O(N<sup>2</sup>)의 알고리즘이다.
    * O(N<sup>2</sup>)알고리즘은 상대적으로 느린 알고리즘으로 간주되기에, 항상 더 빠른 대안은 없을지 생각하는 데 시간을 투자해야한다.
    
### 선형 해결법
  * 아래 처럼 루프가 1개이며, 찾아봤던 수를 existingNumbers 라는 배열에 기록한다.
  ```javascript
  function hasDuplicateValue(array){
    var existingNumbers = [];
    for(var i = 0; i < array.length; i++){
      if(existingNumbers[array[i]] === undefined){
        existingNumbers[array[i]] = 1;
      }else{
        return true;
      }
    }
    return false;
  }
  ```
  * 이 알고리즘은 데이터 원소 N개가 있을 때 비교를 N번 한다. 단 하나의 루프에서 단지 배열에 있는 원소 수만큼 순회하기 때문이다.
    * 다시말해, O(N)이기 때문에 위의 O(N<sup>2</sup>)보다 훨씬 빠르게 최적화를 시켜줄 수 있다.
    
### 마무리
  * 빅 오 표기법을 명확히 이해하면 느린 코드를 식별해 내고 두 경쟁 알고리즘 중 더 빠른 알고리즘을 분명하게 골라낼 수 있다.
  
  
* [위로](#4장-빅-오로-코드-속드-올리기)
