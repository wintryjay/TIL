#### 어떤 운영 체제에서 어떤 프로그래밍 언어를 사용하든 좋은 프로그램은 항상 적절한 자료 구조와 효율적인 알고리즘을 바탕으로 한다. 
	- 비전공자인 나로서는 기본구조를 알아야 한다고 생각했고, 많은 서칭을 통해서 괜찮은 책을 추천받아 이를 공부하고 여기에 정리하고자 한다.
		* 공부할 책은 "누구나 자료구조와 알고리즘(도서출판 길벗)" 이다.

</br>
 
## 1장 자료구조가 중요한 까닭

* [1.1 배열](#배열-기초-자료-구조)
* [1.2 읽기](#읽기)
* [1.3 검색](#검색)
* [1.4 삽입](#삽입)
* [1.5 삭제](#삭제)
* [1.6 집합](#집합-단-하나의-규칙이-효율성을-바꾼다)
* [1.7 마무리](#마무리)

[뒤로](https://github.com/wintryjay/TIL/tree/main/DataStructure)

</br>

### 1장 자료 구조가 중요한 까닭
	- "프로그래밍"은 데이터를 주로 다루는 것이다.
		* "데이터"는 일반적으로 모든 유형의 정보를 망라하는 용어이며 가장 기초적인 수와 문자열로 이뤄진다.
	- "자료구조"는 데이터를 조직하는 방법이다.
		* 데이터 조직은 "코드의 실행 속도"에 미치는 영향이 크다.
		* 우리가 소프트웨어를 문제없이, 빠르게 실행할 수 있는 명쾌한 코드를 작성하는 능력을 갖추고 소프트웨어 공학자가 가져야하는 
		  전문성을 키우려면 다양한 자료 구조를 알고, 각각의 자료 구조가 개발 중인 프로그램의 성능에 어떤 영향을 미칠지 확실히 이해하고 있어야 한다.

### 배열: 기초 자료 구조
	- "배열" 단순히 데이터 원소들의 리스트
	- "인덱스"는 특정 데이터가 배열의 어디에 있는지 알려주는 숫자
		* 대부분의 프로그래밍 언어에서 인덱스는 0부터 시작한다.
	- "연산"은 대부분의 자료구조로 4가지 기본 방법을 의미한다.
		* "읽기"는 자료 구조 내 특정 위치를 찾아보는 것이다. 배열에서는 특정 인덱스의 값을 찾아보는 것을 뜻한다.
		  가령, 인덱스 2에 들어 있는 물건을 찾는 것이 배열 읽기의 예이다.
		* "검색"은 자료구 구조 내에서 특정 값을 찾는 것이다. 배열에서 특정 값이 배열에 들어 있는지,
		  만약 그렇다면 어떤 인덱스에 있는지 알아보는 것을 뜻한다. 어떤 인덱스에 있는지 알아보는 게 배열 검색이다.
		* "삽입"은 자료 구조에 새로운 값을 추가하는 것이다. 배열이라면 배열 내에 슬롯을 더 만들어 새 값을 추가하는 것을 뜻한다.
		* "삭제"는 자료 구조에서 값을 제거하는 것이다. 배열에서는 배열의 값 중 하나를 제거하는 것을 뜻한다.
		* cf) "CRUD"는 대부분의 컴퓨터 소프트웨어가 가지는 기본적인 데이터 처리 기능인 Create, Read, Update, Delete를 묶어서 일컫는 말이다.
	- "연산"이 얼마나 빠른가를 측정할 때는 순수하게 시간 관점에서 연산이 얼마나 빠른가가 아니라 얼마나 많은 단계가 필요한지를 논해야 한다.
		* 시간은 연산을 실행하는 하드웨어에 따라 항상 바뀌므로 시간을 기준으로 속도를 측정하면 신뢰할 수 없다. 대신, 연산의 속도를 측정할 때
		  얼마나 많은 단계(steps)가 필요한가를 따져볼 수 있다.
		* 결국 단계 수를 측정하는 게 연산의 속도를 분석하는 핵심 비결이다. 연산의 속도 측정은 연산의 시간 복잡도 측정으로도 알려져 있다.
			* 속도 = 시간 복잡도 = 효율성 = 성능 = 연산에 걸리는 단계 수

### 읽기
	- "읽기"는 배열 내 특정 인덱스에 어떤 값이 들어 있는지 찾아보는 것
		* 배열에서 읽기는 실제로 딱 "한 단계"다.
		* "한 단계"로 끝나는 연산은 당연히 가장 빠른 연산 유형이다. ( 'O(1)'이 가장 빠름 )
		* 배열이 그토록 강력한 자료 구조인 이유 중 하나는 어떤 인덱스의 값이든 빠르게 찾을 수 있기 때문이다.
	- 프로그램에서는 배열을 선언하면 컴퓨터는 프로그램이 쓸 수 있는 연속된 빈 셀들의 집합을 할당한다.
	- 컴퓨터 메모리 내에 각 셀에는 특정 주소가 있다. 각 셀의 메모리 주소는 앞 셀의 주소에서 1씩 증가한다.
		* 컴퓨터는 모든 메모리 주소에 한 번에 갈 수 있다.
		* 각 배열에 저장된 내용은 메모리의 시작 주소다. 따라서 컴퓨터는 손쉽게 시작 주소를 얻는다.
		* 배열의 인덱스는 0부터 시작한다.
		* 인덱스 0의 메모리 주소는 1010이다.
		* 인덱스 3을 찾으려면 1010+3인 1013 메모리 주소로 간다.
		
### 검색
	- 배열 "검색"은 배열에 특정 값이 있는지 알아본 후, 있다면 어떤 인덱스에 있는지 찾는 것이다.
		* 사람의 눈으로는 한번에 찾고 머릿속으로 빠르게 인덱스를 계산할 수 있지만, 컴퓨터는 차례대로 찾을 수 밖에 없다.
		* 차례대로 찾는 것을 하나의 "단계"로 볼 수 있다.
	- 컴퓨터가 한 번에 한 셀씩 확인하는 방법을 선형 검색이라 부른다.
		* N개의 셀로 이뤄진 배열은 선형 검색에 최대 N개의 단계가 필요하다고 말할 수 있다. 이때 N은 어떤 수든 넣을 수 있는 단순한 변수다.
	- 어쨌든 검색은 읽기보다 분명히 덜 효율적이다.
	
### 삽입
	- "삽입"연산은 배열의 어디에 데이터를 삽입하는가에 따라 효율성이 다르다.
		* 배열의 "끝"에 데이터를 삽입하면, 컴퓨터는 배열이 시작되는 메모리 주소를 알기 때문에 배열이 현재 얼마나 많은 원소를 포함하는지도
		  알고 있으므로 새원소를 추가해야 하는 메모리 주소가 어딘지 계산할 수 있고, 이는 한 단계면 된다.
		* "처음"이나 "중간"에 데이터를 삽입하면, 삽입할 공간을 만들기 위해 데이터 조각을 이동시켜야 하므로 단계가 늘어난다.
	- 배열 삽입에서 "최악의 시나리오", 즉 삽입에 가장 많은 단계가 걸리는 시나리오는 데이터를 배열의 맨 앞에 삽입할 때다.
		* 배열의 앞에 삽입하면 배열 내 모든 값을 한 셀씩 오른쪽으로 옮겨야 하기 때문이다.
		* 원소 N개를 포함하는 배열에서 최악의 시나리오일 때 삽입에는 N+1단계가 걸린다. 최악의 시나이로에서는 N번의 이동(배열의 모든 데이터 원소)과
		  1번의 삽입으로 배열의 맨 앞에 값을 삽입하기 때문이다.
	- "삭제"는 삽입과 비슷하지만 순서가 반대다.

### 삭제
	- "삭제"는 특정 인덱스의 값을 제거하는 과정이다.
		* 배열은 중간에 빈 공간을 허용하지 않는다.
	- 결론적으로 삭제에서 실제로 삭제가 일어나는 데는 단 한 단계지만, 삭제로 생긴 공간을 없애려면 왼쪽으로 데이터를 이동시키는 단계가 더 필요하다.
	- 원소 삭제에서 "최악의 시나리오"는 배열의 첫 번째 원소를 삭제하는 것이다.
		* 이렇게 되면 배열에서 허용하지 않는 인덱스 0이 비게 되고, 남아 있는 모든 원소를 왼쪽으로 이동시켜 빈 공간을 채워야 한다.
		* 원소 N개를 포함하는 배열에서 삭제에 필요한 최대 단계 수는 N단계라고 결론 지을 수 있다.
		
### 집합: 단 하나의 규칙이 효율성을 바꾼다
	- "집합"은 중복 값을 허용하지 않는 자료 구조다.
		* 즉, 집합은 중복 데이터가 없어야 할 때 유용하다.
		* 배열 기반 집합과 일반적인 배열 간 유일한 차이점은 집합은 중복 값의 삽입을 절대 허용하지 않는다는 점이다.
		* 즉, 집합은 중복 데이터가 없어야 할 때 유용하다.
	- "집합 읽기"는 배열 읽기와 완전히 똑같다. 컴퓨터가 특정 인덱스에 들어 있는 값을 찾는 데 한 단계면 된다.
	- "집합 검색"도 배열 검색과 아무런 차이가 없다. 어떤 값이 집합 내에 존재하는지 알려면 검색에 최대 N단계까지 걸릴 수 있다.
	- "집합 삭제"도 배열과 동일하다. 값을 삭제하고, 빈 공간을 메꾸기 위해 N단계를 거쳐 데이터를 왼쪽으로 옮긴다.
	- "집합 삽입"만 배열과 다르다.
		* 집합에서는 먼저 이 값이 이미 집합에 들어 있는지 결정해야 한다. 중복 데이터를 막는게 집합의 역할이기 때문이다. 따라서 모든 삽입에는 검색이 우선이다.
		* 값을 집합의 맨 앞에 삽입하는 "최악의 시나리오"일 때 컴퓨터는 셀 N개를 검색해서 집합이 그 값을 포함하지 않음을 확인한 후,
		  또 다른 N단계로 모든 데이터를 옮겨야 하며, 마지막 단계에서 새 값을 삽입해야한다. 총 2N+1 단계다.
	- 삽입이 일반적인 배열보다 집합에서 느리다는 이유만으로 집합을 사용하지 말아야 하는 것은 아니다. 중복 데이터가 없어야 할 때는 집합을 사용해야 한다.
		* 하지만 이런 요구사항이 없다면 집합 삽입보다 배열 삽입이 더 효율적이므로 배열이 나을 수 있다.
		* 어플리케이션의 요구사항을 먼저 분석한 후 어떤 자료 구조가 더 적합한지 결정해야 한다.
		
### 마무리
	- 자료 구조의 성능 측정은 연산에 필요한 단계 수를 구하는 게 핵심이다.
	- 프로그램에 꼭 맞는 자료 구조를 선택했느냐?가 핵심이다.
	
* [위로](#1장-자료-구조가-중요한-까닭)
	
